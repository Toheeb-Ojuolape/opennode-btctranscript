"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenNodeClient = void 0;
const axios_1 = __importDefault(require("axios"));
const node_crypto_1 = require("node:crypto");
const node_util_1 = require("node:util");
const OpenNodeError_1 = require("./OpenNodeError");
const version = require("../package.json")?.version || "local";
const packageVersion = `npm-opennode-v${version}`;
class OpenNodeClient {
    constructor(key, environment = "live") {
        this.initiateWithdrawal = (0, node_util_1.deprecate)((withdrawal) => {
            return this.instanceV1.post(`/withdrawals`, withdrawal);
        }, "This method is deprecated and not recommend for use. Please use the asynchronous version (initiateWithdrawalAsync)", "OPN001");
        this.api_key = key;
        this.env = environment;
        const createInstance = (version) => {
            const client = axios_1.default.create({
                baseURL: environment === "live"
                    ? `https://api.opennode.com/${version}`
                    : `https://dev-api.opennode.com/${version}`,
                timeout: 15000,
                headers: {
                    Authorization: this.api_key,
                    Connection: "Keep-Alive",
                    "Content-Type": "application/json",
                    "Keep-Alive": "timeout=10",
                    "User-Agent": packageVersion,
                },
            });
            client.interceptors.response.use(({ data }) => ("data" in data ? data.data : data), (err) => {
                if (axios_1.default.isAxiosError(err)) {
                    throw new OpenNodeError_1.OpenNodeError(err.message, err.response?.statusText, err.response?.status);
                }
                if (err instanceof Error)
                    throw err;
                return err;
            });
            return client;
        };
        this.instanceV1 = createInstance("v1");
        this.instanceV2 = createInstance("v2");
    }
    async createCharge(charge) {
        return this.instanceV1.post(`/charges`, charge);
    }
    async chargeInfo(id) {
        return this.instanceV1.get(`/charge/${id}`);
    }
    async listCharges() {
        return this.instanceV1.get(`/charges`);
    }
    async withdrawalInfo(id) {
        return this.instanceV1.get(`/withdrawal/${id}`);
    }
    async listWithdrawals() {
        return this.instanceV1.get(`/withdrawals`);
    }
    async listRates() {
        return this.instanceV1.get(`/rates`);
    }
    async listCurrencies() {
        return this.instanceV1.get(`/currencies`);
    }
    async getBalance() {
        return this.accountBalance();
    }
    async userBalance() {
        return this.accountBalance();
    }
    async accountBalance() {
        return this.instanceV1.get(`/account/balance`);
    }
    verifySignature(charge) {
        const hash = (0, node_crypto_1.createHmac)("sha256", this.api_key)
            .update(charge.id)
            .digest("hex");
        return hash === charge.hashed_order;
    }
    async refundCharge(refund) {
        return this.instanceV1.post(`/refunds`, refund);
    }
    async listRefunds() {
        return this.instanceV1.get(`/refunds`);
    }
    async refundInfo(id) {
        return this.instanceV1.get(`/refund/${id}`);
    }
    async initiatePayout(payout) {
        return this.instanceV2.post(`/payouts`, payout);
    }
    async payoutInfo(id) {
        return this.instanceV2.get(`/payout/${id}`);
    }
    async initiateExchange(exchange) {
        return this.instanceV2.post("/exchanges", exchange);
    }
    async initiateWithdrawalAsync(withdrawal) {
        return this.instanceV2.post("/withdrawals", withdrawal);
    }
    async createLnUrlWithdrawal(lnUrlWithdrawal) {
        return this.instanceV2.post(`/lnurl-withdrawal`, lnUrlWithdrawal);
    }
}
exports.OpenNodeClient = OpenNodeClient;
//# sourceMappingURL=client.js.map